<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC 调试工具</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #4ec9b0;
            border-bottom: 2px solid #4ec9b0;
            padding-bottom: 10px;
        }
        .section {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .section h2 {
            color: #569cd6;
            margin-top: 0;
        }
        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status.success { background: #0e8a16; color: white; }
        .status.error { background: #d73a49; color: white; }
        .status.warning { background: #f66a0a; color: white; }
        .status.info { background: #0366d6; color: white; }

        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #1177bb;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        #log {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.6;
        }
        .log-entry {
            margin-bottom: 5px;
        }
        .log-entry.info { color: #4ec9b0; }
        .log-entry.success { color: #4ec9b0; }
        .log-entry.error { color: #f48771; }
        .log-entry.warning { color: #dcdcaa; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-item {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }
        .stat-label {
            color: #858585;
            font-size: 12px;
            margin-bottom: 5px;
        }
        .stat-value {
            color: #4ec9b0;
            font-size: 24px;
            font-weight: bold;
        }

        canvas {
            border: 2px solid #3e3e42;
            border-radius: 8px;
            background: #000;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 WebRTC JPEG 视频流调试工具</h1>

        <div class="section">
            <h2>🔌 连接状态</h2>
            <div>
                <strong>信令服务器:</strong>
                <span class="status info" id="signalingStatus">未连接</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>WebRTC:</strong>
                <span class="status info" id="webrtcStatus">未连接</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>ICE状态:</strong>
                <span class="status info" id="iceStatus">new</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>Data Channel:</strong>
                <span class="status info" id="dataChannelStatus">未创建</span>
            </div>
        </div>

        <div class="section">
            <h2>🎮 控制面板</h2>
            <button id="btnConnect">1. 连接WebRTC</button>
            <button id="btnRequestVideo" disabled>2. 请求视频流</button>
            <button id="btnDisconnect" disabled>3. 断开连接</button>
            <button id="btnClearLog">清除日志</button>
        </div>

        <div class="section">
            <h2>📊 统计信息</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">已接收帧数</div>
                    <div class="stat-value" id="frameCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">当前FPS</div>
                    <div class="stat-value" id="fps">0.0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">总接收数据</div>
                    <div class="stat-value" id="totalBytes">0 B</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">平均帧大小</div>
                    <div class="stat-value" id="avgFrameSize">0 B</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>📹 视频显示</h2>
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="section">
            <h2>📝 日志输出</h2>
            <div id="log"></div>
        </div>
    </div>

    <script>
        // 状态管理
        let pc = null;
        let ws = null;
        let dataChannel = null;
        let clientId = null;

        // 统计信息
        let frameCount = 0;
        let totalBytes = 0;
        let frameTimestamps = [];
        let jpegBuffer = [];
        let currentFrameSize = 0;
        let frameReceiving = false;

        // Canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // UI元素
        const signalingStatus = document.getElementById('signalingStatus');
        const webrtcStatus = document.getElementById('webrtcStatus');
        const iceStatus = document.getElementById('iceStatus');
        const dataChannelStatus = document.getElementById('dataChannelStatus');
        const logDiv = document.getElementById('log');

        const btnConnect = document.getElementById('btnConnect');
        const btnRequestVideo = document.getElementById('btnRequestVideo');
        const btnDisconnect = document.getElementById('btnDisconnect');
        const btnClearLog = document.getElementById('btnClearLog');

        // 日志函数
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateStatus(element, text, type) {
            element.textContent = text;
            element.className = `status ${type}`;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateStats() {
            document.getElementById('frameCount').textContent = frameCount;
            document.getElementById('totalBytes').textContent = formatBytes(totalBytes);

            if (frameCount > 0) {
                document.getElementById('avgFrameSize').textContent = formatBytes(totalBytes / frameCount);
            }

            // 计算FPS
            const now = performance.now();
            frameTimestamps = frameTimestamps.filter(t => now - t < 1000);
            document.getElementById('fps').textContent = frameTimestamps.length.toFixed(1);
        }

        // WebRTC连接
        async function connectWebRTC() {
            try {
                log('🔌 开始连接WebRTC...', 'info');
                btnConnect.disabled = true;

                // 连接信令服务器
                const wsUrl = 'ws://localhost:8083';
                log(`🌐 连接信令服务器: ${wsUrl}`, 'info');
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    log('✅ 信令服务器连接成功', 'success');
                    updateStatus(signalingStatus, '已连接', 'success');

                    // 发送认证
                    const authMsg = {
                        type: 'auth',
                        data: {
                            client_type: 'web_client',
                            client_id: `debug_${Date.now()}`
                        },
                        timestamp: Date.now()
                    };
                    ws.send(JSON.stringify(authMsg));
                    log('📤 发送认证消息', 'info');
                };

                ws.onerror = (error) => {
                    log('❌ 信令服务器连接错误', 'error');
                    updateStatus(signalingStatus, '连接失败', 'error');
                };

                ws.onclose = () => {
                    log('🔌 信令服务器连接关闭', 'warning');
                    updateStatus(signalingStatus, '已断开', 'warning');
                };

                ws.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        handleSignalingMessage(msg);
                    } catch (error) {
                        log(`❌ 解析消息失败: ${error.message}`, 'error');
                    }
                };

                // 创建PeerConnection
                const config = {
                    iceServers: [] // 本地连接不需要STUN
                };
                pc = new RTCPeerConnection(config);
                log('✅ PeerConnection已创建', 'success');

                // 设置事件处理
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const msg = {
                            type: 'ice_candidate',
                            data: {
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex
                            },
                            timestamp: Date.now()
                        };
                        ws.send(JSON.stringify(msg));
                        log(`📤 发送ICE候选: ${event.candidate.candidate.substring(0, 50)}...`, 'info');
                    }
                };

                pc.oniceconnectionstatechange = () => {
                    const state = pc.iceConnectionState;
                    log(`🧊 ICE连接状态: ${state}`, state === 'connected' ? 'success' : 'info');
                    updateStatus(iceStatus, state, state === 'connected' ? 'success' : 'info');
                };

                pc.onconnectionstatechange = () => {
                    const state = pc.connectionState;
                    log(`🔗 WebRTC连接状态: ${state}`, state === 'connected' ? 'success' : 'info');
                    updateStatus(webrtcStatus, state, state === 'connected' ? 'success' : 'info');
                };

                pc.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    log(`📡 收到Data Channel: ${dataChannel.label}`, 'success');
                    setupDataChannel();
                };

                updateStatus(webrtcStatus, '等待Offer', 'warning');

            } catch (error) {
                log(`❌ 连接失败: ${error.message}`, 'error');
                btnConnect.disabled = false;
            }
        }

        function setupDataChannel() {
            dataChannel.binaryType = 'arraybuffer';

            dataChannel.onopen = () => {
                log('✅ Data Channel已打开', 'success');
                updateStatus(dataChannelStatus, '已打开', 'success');
                btnRequestVideo.disabled = false;
                btnDisconnect.disabled = false;
            };

            dataChannel.onclose = () => {
                log('❌ Data Channel已关闭', 'warning');
                updateStatus(dataChannelStatus, '已关闭', 'warning');
            };

            dataChannel.onerror = (error) => {
                log(`❌ Data Channel错误: ${error}`, 'error');
            };

            dataChannel.onmessage = (event) => {
                handleDataChannelMessage(event.data);
            };
        }

        function handleDataChannelMessage(data) {
            if (!frameReceiving) {
                // 新帧开始，读取帧大小（前4字节）
                if (data.byteLength >= 4) {
                    const dataView = new DataView(data);
                    currentFrameSize = (dataView.getUint8(0) << 24) |
                                      (dataView.getUint8(1) << 16) |
                                      (dataView.getUint8(2) << 8) |
                                      dataView.getUint8(3);

                    log(`📦 新JPEG帧开始，大小: ${currentFrameSize} bytes`, 'info');

                    frameReceiving = true;
                    jpegBuffer = [];

                    // 保存剩余数据
                    if (data.byteLength > 4) {
                        const jpegData = data.slice(4);
                        jpegBuffer.push(jpegData);
                    }

                    checkFrameComplete();
                }
            } else {
                // 继续接收帧数据
                jpegBuffer.push(data);
                checkFrameComplete();
            }
        }

        function checkFrameComplete() {
            // 计算已接收大小
            let receivedSize = 0;
            for (const buffer of jpegBuffer) {
                receivedSize += buffer.byteLength;
            }

            // 检查是否完整
            if (receivedSize >= currentFrameSize) {
                log(`✅ JPEG帧接收完成: ${receivedSize} bytes`, 'success');

                // 合并数据
                const fullBuffer = new ArrayBuffer(currentFrameSize);
                const uint8View = new Uint8Array(fullBuffer);

                let offset = 0;
                for (const buffer of jpegBuffer) {
                    const bufferView = new Uint8Array(buffer);
                    const copyLength = Math.min(buffer.byteLength, currentFrameSize - offset);
                    uint8View.set(bufferView.slice(0, copyLength), offset);
                    offset += copyLength;
                    if (offset >= currentFrameSize) break;
                }

                // 验证JPEG头
                if (uint8View[0] === 0xFF && uint8View[1] === 0xD8) {
                    log('✅ JPEG文件头验证通过', 'success');
                    displayJpegFrame(fullBuffer);
                } else {
                    log(`❌ JPEG文件头无效: ${uint8View[0].toString(16)} ${uint8View[1].toString(16)}`, 'error');
                }

                // 重置状态
                frameReceiving = false;
                currentFrameSize = 0;
                jpegBuffer = [];
            } else {
                // 显示进度
                const progress = (receivedSize / currentFrameSize * 100).toFixed(1);
                log(`📊 接收进度: ${receivedSize}/${currentFrameSize} (${progress}%)`, 'info');
            }
        }

        function displayJpegFrame(jpegData) {
            const blob = new Blob([jpegData], { type: 'image/jpeg' });
            const imageUrl = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = () => {
                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 保持宽高比绘制
                const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                const x = (canvas.width - scaledWidth) / 2;
                const y = (canvas.height - scaledHeight) / 2;

                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);

                // 更新统计
                frameCount++;
                totalBytes += jpegData.byteLength;
                frameTimestamps.push(performance.now());
                updateStats();

                URL.revokeObjectURL(imageUrl);

                if (frameCount % 10 === 0) {
                    log(`📹 已显示第 ${frameCount} 帧`, 'success');
                }
            };

            img.onerror = () => {
                log('❌ JPEG图像加载失败', 'error');
                URL.revokeObjectURL(imageUrl);
            };

            img.src = imageUrl;
        }

        async function handleSignalingMessage(msg) {
            log(`📩 收到信令消息: ${msg.type}`, 'info');

            switch (msg.type) {
                case 'auth_success':
                    clientId = msg.client_id;
                    log(`✅ 认证成功, Client ID: ${clientId}`, 'success');
                    break;

                case 'offer':
                    log('📤 收到Offer，创建Answer...', 'info');
                    const offer = new RTCSessionDescription({
                        type: 'offer',
                        sdp: msg.data.sdp
                    });

                    await pc.setRemoteDescription(offer);
                    log('✅ 设置远程描述成功', 'success');

                    const answer = await pc.createAnswer();

                    // 修复SDP
                    if (answer.sdp) {
                        answer.sdp = answer.sdp.replace(/a=inactive/g, 'a=recvonly');
                    }

                    await pc.setLocalDescription(answer);
                    log('✅ 设置本地描述成功', 'success');

                    const answerMsg = {
                        type: 'answer',
                        data: {
                            type: 'answer',
                            sdp: answer.sdp
                        },
                        timestamp: Date.now()
                    };
                    ws.send(JSON.stringify(answerMsg));
                    log('📤 发送Answer', 'success');
                    break;

                case 'ice_candidate':
                    if (pc.remoteDescription) {
                        const candidate = new RTCIceCandidate({
                            candidate: msg.data.candidate,
                            sdpMid: msg.data.sdpMid,
                            sdpMLineIndex: msg.data.sdpMLineIndex
                        });
                        await pc.addIceCandidate(candidate);
                        log('✅ 添加ICE候选成功', 'success');
                    }
                    break;
            }
        }

        function requestVideoStream() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const msg = {
                    type: 'request_offer',
                    data: {
                        source_id: 'camera_01'  // 请求默认源
                    },
                    timestamp: Date.now()
                };
                ws.send(JSON.stringify(msg));
                log('📤 请求视频流 (source: camera_01)', 'info');
            }
        }

        function disconnect() {
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (pc) {
                pc.close();
                pc = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }

            updateStatus(signalingStatus, '未连接', 'info');
            updateStatus(webrtcStatus, '未连接', 'info');
            updateStatus(iceStatus, 'new', 'info');
            updateStatus(dataChannelStatus, '未创建', 'info');

            btnConnect.disabled = false;
            btnRequestVideo.disabled = true;
            btnDisconnect.disabled = true;

            log('🔌 已断开所有连接', 'warning');
        }

        // 事件绑定
        btnConnect.onclick = connectWebRTC;
        btnRequestVideo.onclick = requestVideoStream;
        btnDisconnect.onclick = disconnect;
        btnClearLog.onclick = () => {
            logDiv.innerHTML = '';
            log('📝 日志已清除', 'info');
        };

        // 初始化
        log('🚀 WebRTC调试工具已加载', 'success');
        log('💡 提示: 请确保后端服务已启动 (VideoAnalyzer on port 8083)', 'info');
    </script>
</body>
</html>