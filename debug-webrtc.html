<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC è°ƒè¯•å·¥å…·</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #4ec9b0;
            border-bottom: 2px solid #4ec9b0;
            padding-bottom: 10px;
        }
        .section {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .section h2 {
            color: #569cd6;
            margin-top: 0;
        }
        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status.success { background: #0e8a16; color: white; }
        .status.error { background: #d73a49; color: white; }
        .status.warning { background: #f66a0a; color: white; }
        .status.info { background: #0366d6; color: white; }

        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #1177bb;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        #log {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.6;
        }
        .log-entry {
            margin-bottom: 5px;
        }
        .log-entry.info { color: #4ec9b0; }
        .log-entry.success { color: #4ec9b0; }
        .log-entry.error { color: #f48771; }
        .log-entry.warning { color: #dcdcaa; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-item {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }
        .stat-label {
            color: #858585;
            font-size: 12px;
            margin-bottom: 5px;
        }
        .stat-value {
            color: #4ec9b0;
            font-size: 24px;
            font-weight: bold;
        }

        canvas {
            border: 2px solid #3e3e42;
            border-radius: 8px;
            background: #000;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” WebRTC JPEG è§†é¢‘æµè°ƒè¯•å·¥å…·</h1>

        <div class="section">
            <h2>ğŸ”Œ è¿æ¥çŠ¶æ€</h2>
            <div>
                <strong>ä¿¡ä»¤æœåŠ¡å™¨:</strong>
                <span class="status info" id="signalingStatus">æœªè¿æ¥</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>WebRTC:</strong>
                <span class="status info" id="webrtcStatus">æœªè¿æ¥</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>ICEçŠ¶æ€:</strong>
                <span class="status info" id="iceStatus">new</span>
            </div>
            <div style="margin-top: 10px;">
                <strong>Data Channel:</strong>
                <span class="status info" id="dataChannelStatus">æœªåˆ›å»º</span>
            </div>
        </div>

        <div class="section">
            <h2>ğŸ® æ§åˆ¶é¢æ¿</h2>
            <button id="btnConnect">1. è¿æ¥WebRTC</button>
            <button id="btnRequestVideo" disabled>2. è¯·æ±‚è§†é¢‘æµ</button>
            <button id="btnDisconnect" disabled>3. æ–­å¼€è¿æ¥</button>
            <button id="btnClearLog">æ¸…é™¤æ—¥å¿—</button>
        </div>

        <div class="section">
            <h2>ğŸ“Š ç»Ÿè®¡ä¿¡æ¯</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">å·²æ¥æ”¶å¸§æ•°</div>
                    <div class="stat-value" id="frameCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å½“å‰FPS</div>
                    <div class="stat-value" id="fps">0.0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">æ€»æ¥æ”¶æ•°æ®</div>
                    <div class="stat-value" id="totalBytes">0 B</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å¹³å‡å¸§å¤§å°</div>
                    <div class="stat-value" id="avgFrameSize">0 B</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>ğŸ“¹ è§†é¢‘æ˜¾ç¤º</h2>
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="section">
            <h2>ğŸ“ æ—¥å¿—è¾“å‡º</h2>
            <div id="log"></div>
        </div>
    </div>

    <script>
        // çŠ¶æ€ç®¡ç†
        let pc = null;
        let ws = null;
        let dataChannel = null;
        let clientId = null;

        // ç»Ÿè®¡ä¿¡æ¯
        let frameCount = 0;
        let totalBytes = 0;
        let frameTimestamps = [];
        let jpegBuffer = [];
        let currentFrameSize = 0;
        let frameReceiving = false;

        // Canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // UIå…ƒç´ 
        const signalingStatus = document.getElementById('signalingStatus');
        const webrtcStatus = document.getElementById('webrtcStatus');
        const iceStatus = document.getElementById('iceStatus');
        const dataChannelStatus = document.getElementById('dataChannelStatus');
        const logDiv = document.getElementById('log');

        const btnConnect = document.getElementById('btnConnect');
        const btnRequestVideo = document.getElementById('btnRequestVideo');
        const btnDisconnect = document.getElementById('btnDisconnect');
        const btnClearLog = document.getElementById('btnClearLog');

        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateStatus(element, text, type) {
            element.textContent = text;
            element.className = `status ${type}`;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateStats() {
            document.getElementById('frameCount').textContent = frameCount;
            document.getElementById('totalBytes').textContent = formatBytes(totalBytes);

            if (frameCount > 0) {
                document.getElementById('avgFrameSize').textContent = formatBytes(totalBytes / frameCount);
            }

            // è®¡ç®—FPS
            const now = performance.now();
            frameTimestamps = frameTimestamps.filter(t => now - t < 1000);
            document.getElementById('fps').textContent = frameTimestamps.length.toFixed(1);
        }

        // WebRTCè¿æ¥
        async function connectWebRTC() {
            try {
                log('ğŸ”Œ å¼€å§‹è¿æ¥WebRTC...', 'info');
                btnConnect.disabled = true;

                // è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨
                const wsUrl = 'ws://localhost:8083';
                log(`ğŸŒ è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨: ${wsUrl}`, 'info');
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    log('âœ… ä¿¡ä»¤æœåŠ¡å™¨è¿æ¥æˆåŠŸ', 'success');
                    updateStatus(signalingStatus, 'å·²è¿æ¥', 'success');

                    // å‘é€è®¤è¯
                    const authMsg = {
                        type: 'auth',
                        data: {
                            client_type: 'web_client',
                            client_id: `debug_${Date.now()}`
                        },
                        timestamp: Date.now()
                    };
                    ws.send(JSON.stringify(authMsg));
                    log('ğŸ“¤ å‘é€è®¤è¯æ¶ˆæ¯', 'info');
                };

                ws.onerror = (error) => {
                    log('âŒ ä¿¡ä»¤æœåŠ¡å™¨è¿æ¥é”™è¯¯', 'error');
                    updateStatus(signalingStatus, 'è¿æ¥å¤±è´¥', 'error');
                };

                ws.onclose = () => {
                    log('ğŸ”Œ ä¿¡ä»¤æœåŠ¡å™¨è¿æ¥å…³é—­', 'warning');
                    updateStatus(signalingStatus, 'å·²æ–­å¼€', 'warning');
                };

                ws.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        handleSignalingMessage(msg);
                    } catch (error) {
                        log(`âŒ è§£ææ¶ˆæ¯å¤±è´¥: ${error.message}`, 'error');
                    }
                };

                // åˆ›å»ºPeerConnection
                const config = {
                    iceServers: [] // æœ¬åœ°è¿æ¥ä¸éœ€è¦STUN
                };
                pc = new RTCPeerConnection(config);
                log('âœ… PeerConnectionå·²åˆ›å»º', 'success');

                // è®¾ç½®äº‹ä»¶å¤„ç†
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const msg = {
                            type: 'ice_candidate',
                            data: {
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex
                            },
                            timestamp: Date.now()
                        };
                        ws.send(JSON.stringify(msg));
                        log(`ğŸ“¤ å‘é€ICEå€™é€‰: ${event.candidate.candidate.substring(0, 50)}...`, 'info');
                    }
                };

                pc.oniceconnectionstatechange = () => {
                    const state = pc.iceConnectionState;
                    log(`ğŸ§Š ICEè¿æ¥çŠ¶æ€: ${state}`, state === 'connected' ? 'success' : 'info');
                    updateStatus(iceStatus, state, state === 'connected' ? 'success' : 'info');
                };

                pc.onconnectionstatechange = () => {
                    const state = pc.connectionState;
                    log(`ğŸ”— WebRTCè¿æ¥çŠ¶æ€: ${state}`, state === 'connected' ? 'success' : 'info');
                    updateStatus(webrtcStatus, state, state === 'connected' ? 'success' : 'info');
                };

                pc.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    log(`ğŸ“¡ æ”¶åˆ°Data Channel: ${dataChannel.label}`, 'success');
                    setupDataChannel();
                };

                updateStatus(webrtcStatus, 'ç­‰å¾…Offer', 'warning');

            } catch (error) {
                log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                btnConnect.disabled = false;
            }
        }

        function setupDataChannel() {
            dataChannel.binaryType = 'arraybuffer';

            dataChannel.onopen = () => {
                log('âœ… Data Channelå·²æ‰“å¼€', 'success');
                updateStatus(dataChannelStatus, 'å·²æ‰“å¼€', 'success');
                btnRequestVideo.disabled = false;
                btnDisconnect.disabled = false;
            };

            dataChannel.onclose = () => {
                log('âŒ Data Channelå·²å…³é—­', 'warning');
                updateStatus(dataChannelStatus, 'å·²å…³é—­', 'warning');
            };

            dataChannel.onerror = (error) => {
                log(`âŒ Data Channelé”™è¯¯: ${error}`, 'error');
            };

            dataChannel.onmessage = (event) => {
                handleDataChannelMessage(event.data);
            };
        }

        function handleDataChannelMessage(data) {
            if (!frameReceiving) {
                // æ–°å¸§å¼€å§‹ï¼Œè¯»å–å¸§å¤§å°ï¼ˆå‰4å­—èŠ‚ï¼‰
                if (data.byteLength >= 4) {
                    const dataView = new DataView(data);
                    currentFrameSize = (dataView.getUint8(0) << 24) |
                                      (dataView.getUint8(1) << 16) |
                                      (dataView.getUint8(2) << 8) |
                                      dataView.getUint8(3);

                    log(`ğŸ“¦ æ–°JPEGå¸§å¼€å§‹ï¼Œå¤§å°: ${currentFrameSize} bytes`, 'info');

                    frameReceiving = true;
                    jpegBuffer = [];

                    // ä¿å­˜å‰©ä½™æ•°æ®
                    if (data.byteLength > 4) {
                        const jpegData = data.slice(4);
                        jpegBuffer.push(jpegData);
                    }

                    checkFrameComplete();
                }
            } else {
                // ç»§ç»­æ¥æ”¶å¸§æ•°æ®
                jpegBuffer.push(data);
                checkFrameComplete();
            }
        }

        function checkFrameComplete() {
            // è®¡ç®—å·²æ¥æ”¶å¤§å°
            let receivedSize = 0;
            for (const buffer of jpegBuffer) {
                receivedSize += buffer.byteLength;
            }

            // æ£€æŸ¥æ˜¯å¦å®Œæ•´
            if (receivedSize >= currentFrameSize) {
                log(`âœ… JPEGå¸§æ¥æ”¶å®Œæˆ: ${receivedSize} bytes`, 'success');

                // åˆå¹¶æ•°æ®
                const fullBuffer = new ArrayBuffer(currentFrameSize);
                const uint8View = new Uint8Array(fullBuffer);

                let offset = 0;
                for (const buffer of jpegBuffer) {
                    const bufferView = new Uint8Array(buffer);
                    const copyLength = Math.min(buffer.byteLength, currentFrameSize - offset);
                    uint8View.set(bufferView.slice(0, copyLength), offset);
                    offset += copyLength;
                    if (offset >= currentFrameSize) break;
                }

                // éªŒè¯JPEGå¤´
                if (uint8View[0] === 0xFF && uint8View[1] === 0xD8) {
                    log('âœ… JPEGæ–‡ä»¶å¤´éªŒè¯é€šè¿‡', 'success');
                    displayJpegFrame(fullBuffer);
                } else {
                    log(`âŒ JPEGæ–‡ä»¶å¤´æ— æ•ˆ: ${uint8View[0].toString(16)} ${uint8View[1].toString(16)}`, 'error');
                }

                // é‡ç½®çŠ¶æ€
                frameReceiving = false;
                currentFrameSize = 0;
                jpegBuffer = [];
            } else {
                // æ˜¾ç¤ºè¿›åº¦
                const progress = (receivedSize / currentFrameSize * 100).toFixed(1);
                log(`ğŸ“Š æ¥æ”¶è¿›åº¦: ${receivedSize}/${currentFrameSize} (${progress}%)`, 'info');
            }
        }

        function displayJpegFrame(jpegData) {
            const blob = new Blob([jpegData], { type: 'image/jpeg' });
            const imageUrl = URL.createObjectURL(blob);

            const img = new Image();
            img.onload = () => {
                // æ¸…é™¤ç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ä¿æŒå®½é«˜æ¯”ç»˜åˆ¶
                const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                const x = (canvas.width - scaledWidth) / 2;
                const y = (canvas.height - scaledHeight) / 2;

                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);

                // æ›´æ–°ç»Ÿè®¡
                frameCount++;
                totalBytes += jpegData.byteLength;
                frameTimestamps.push(performance.now());
                updateStats();

                URL.revokeObjectURL(imageUrl);

                if (frameCount % 10 === 0) {
                    log(`ğŸ“¹ å·²æ˜¾ç¤ºç¬¬ ${frameCount} å¸§`, 'success');
                }
            };

            img.onerror = () => {
                log('âŒ JPEGå›¾åƒåŠ è½½å¤±è´¥', 'error');
                URL.revokeObjectURL(imageUrl);
            };

            img.src = imageUrl;
        }

        async function handleSignalingMessage(msg) {
            log(`ğŸ“© æ”¶åˆ°ä¿¡ä»¤æ¶ˆæ¯: ${msg.type}`, 'info');

            switch (msg.type) {
                case 'auth_success':
                    clientId = msg.client_id;
                    log(`âœ… è®¤è¯æˆåŠŸ, Client ID: ${clientId}`, 'success');
                    break;

                case 'offer':
                    log('ğŸ“¤ æ”¶åˆ°Offerï¼Œåˆ›å»ºAnswer...', 'info');
                    const offer = new RTCSessionDescription({
                        type: 'offer',
                        sdp: msg.data.sdp
                    });

                    await pc.setRemoteDescription(offer);
                    log('âœ… è®¾ç½®è¿œç¨‹æè¿°æˆåŠŸ', 'success');

                    const answer = await pc.createAnswer();

                    // ä¿®å¤SDP
                    if (answer.sdp) {
                        answer.sdp = answer.sdp.replace(/a=inactive/g, 'a=recvonly');
                    }

                    await pc.setLocalDescription(answer);
                    log('âœ… è®¾ç½®æœ¬åœ°æè¿°æˆåŠŸ', 'success');

                    const answerMsg = {
                        type: 'answer',
                        data: {
                            type: 'answer',
                            sdp: answer.sdp
                        },
                        timestamp: Date.now()
                    };
                    ws.send(JSON.stringify(answerMsg));
                    log('ğŸ“¤ å‘é€Answer', 'success');
                    break;

                case 'ice_candidate':
                    if (pc.remoteDescription) {
                        const candidate = new RTCIceCandidate({
                            candidate: msg.data.candidate,
                            sdpMid: msg.data.sdpMid,
                            sdpMLineIndex: msg.data.sdpMLineIndex
                        });
                        await pc.addIceCandidate(candidate);
                        log('âœ… æ·»åŠ ICEå€™é€‰æˆåŠŸ', 'success');
                    }
                    break;
            }
        }

        function requestVideoStream() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const msg = {
                    type: 'request_offer',
                    data: {
                        source_id: 'camera_01'  // è¯·æ±‚é»˜è®¤æº
                    },
                    timestamp: Date.now()
                };
                ws.send(JSON.stringify(msg));
                log('ğŸ“¤ è¯·æ±‚è§†é¢‘æµ (source: camera_01)', 'info');
            }
        }

        function disconnect() {
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (pc) {
                pc.close();
                pc = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }

            updateStatus(signalingStatus, 'æœªè¿æ¥', 'info');
            updateStatus(webrtcStatus, 'æœªè¿æ¥', 'info');
            updateStatus(iceStatus, 'new', 'info');
            updateStatus(dataChannelStatus, 'æœªåˆ›å»º', 'info');

            btnConnect.disabled = false;
            btnRequestVideo.disabled = true;
            btnDisconnect.disabled = true;

            log('ğŸ”Œ å·²æ–­å¼€æ‰€æœ‰è¿æ¥', 'warning');
        }

        // äº‹ä»¶ç»‘å®š
        btnConnect.onclick = connectWebRTC;
        btnRequestVideo.onclick = requestVideoStream;
        btnDisconnect.onclick = disconnect;
        btnClearLog.onclick = () => {
            logDiv.innerHTML = '';
            log('ğŸ“ æ—¥å¿—å·²æ¸…é™¤', 'info');
        };

        // åˆå§‹åŒ–
        log('ğŸš€ WebRTCè°ƒè¯•å·¥å…·å·²åŠ è½½', 'success');
        log('ğŸ’¡ æç¤º: è¯·ç¡®ä¿åç«¯æœåŠ¡å·²å¯åŠ¨ (VideoAnalyzer on port 8083)', 'info');
    </script>
</body>
</html>