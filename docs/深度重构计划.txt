 无适配器深度重写：分阶段改造路线图

  ———

  阶段 0：准备与基线确认

  - 目标：保持现有功能可构建、可运行，记录关键流程（订阅、模型切换、推流）用于后续
  回归。
  - 动作：
      - 固定当前主分支（或创建重构分支）。
      - 输出一次端到端日志（REST 调用 → 推理 → 指标）作为回归基线。
      - 评估第三方依赖是否满足目标（FFmpeg/ORT/libdatachannel 等）。

  ———

  阶段 1：基础分层骨架搭建

  - 目标：创建文档中约定的新目录 / 接口文件，并提供最小实现（可返回占位数据）。
  - 动作：
      - 新增 src/core, src/analyzer, src/media, src/server 目录及 core/utils.hpp、
  analyzer/interfaces.hpp 等头文件，定义统一的数据结构：
          - Frame, LetterboxMeta, TensorView, ModelOutput, AnalysisType 等。
          - IPreprocessor, IModelSession, IPostprocessor, IRenderer, IFrameFilter、
  ISwitchableSource, IEncoder, ITransport 等接口。
      - 更新 CMakeLists.txt，确保新目录纳入编译。
      - 提供“空”实现（返回 true/空集合），与现有逻辑并存，保证构建通过。
 
  ———
 
  阶段 2：重写 Analyzer 子系统
 
  - 目标：把现有推理相关逻辑拆分进 analyzer/，实现 Analyzer 外壳。
  - 动作：
      - 将 PrePost、YOLO、OnnxRuntimeBackend 重构为：
          - preproc_letterbox_cpu.{hpp,cpp}（实现 IPreprocessor）。
          - ort_session.{hpp,cpp}（封装 ONNX Session，直接实现 IModelSession，支持
  IOBinding 占位）。
          - postproc_yolo_det.{hpp,cpp}、postproc_yolo_seg.{hpp,cpp}、postproc_detr.
  {hpp,cpp}（实现 IPostprocessor）。
          - render_box/render_mask（实现 IRenderer，完成绘制与叠加）。
      - 新建 analyzer/analyzer.{hpp,cpp}，组合上述组件，提供 process(const Frame&,
  Frame&)。
      - 将旧的 VideoAnalyzer::processRequest 和模型加载逻辑逐步迁移/复用到新结构中，保
  留功能等价性。
      - 临时保留现有 VideoAnalyzer 外部接口（供 REST 使用），但内部调用新的 Analyzer
  实现。
 
  ———
 
  阶段 3：重写媒体层（Source / Encoder / Transport）
 
  - 目标：让解码、编码、发布组件符合接口设计，可被 Pipeline 调用。
  - 动作：
      - media/source_switchable_rtsp.{hpp,cpp}：使用 FFmpeg send/receive API 实现
  ISwitchableSource，支持动态 URL 切换、重试机制。
      - media/encoder_h264_ffmpeg.{hpp,cpp}：基于 FFmpeg avcodec_send_frame/
  receive_packet 实现 IEncoder。
      - media/transport_whip.{hpp,cpp}：封装 WHIP HTTP(S) 上传逻辑（可初期复用现有
  WebRTC 简化逻辑，逐步替换）。
      - 将现有 WebRTCStreamer 中临时代码分离/整合，确保与 IEncoder/ITransport 配合。
      - 为每个组件添加最基本的错误处理、状态日志。
 
  ———
 
  - 目标：替换现有 Pipeline 与 TrackManager，实现文档中的“按需生产 + 动态切换”。
  - 动作：
          - utils.hpp 辅助函数。
          - engine_manager.{hpp,cpp}：封装 Execution Provider 切换。
          - pipeline.{hpp,cpp}：处理 Source→Decode→Analyzer→Encode→Transport，具备有界
  队列、丢旧保新、错误重试。
          - pipeline_builder.{hpp,cpp}：根据 Profile/模型参数构建 Pipeline。
          - factories.{hpp,cpp}：引入组合根（Stage 接线）。
          - track_manager.{hpp,cpp}：维护 (stream, profile)→Pipeline，多订阅引用计数、
  调用 start/stop/switch。
      - 将现有 VideoAnalyzer 中的订阅/切换逻辑迁移到新的 TrackManager；VideoAnalyzer
  转换成组合根 + REST 接口适配。

  ———

  阶段 5：REST 层与主程序重构

  - 目标：让 /api/... 控制面使用新 TrackManager/EngineManager。
  - 动作：
      - 在 server/rest.cpp 重写 REST Handler，处理订阅、切源、切模、切任务、参数热更
  新、引擎切换等路由。
      - 组合根：在新 composition_root.cpp 中加载配置（config/*.yaml），创建
  Factories、TrackManager、EngineManager 等。
      - main.cpp 更新为：解析 CLI → 组合根 → 启动 REST/WebRTC/WHIP → 维护信号处理。
      - 确保 config_loader 更新为新结构需要的 Profile/Model/Engine 配置。

  ———

  阶段 6：清理、验证与优化

  - 目标：删除旧模块（VideoAnalyzer.cpp 原有分支、临时类），补全缺陷。
  - 动作：
      - 移除已经迁移完的旧代码（防止重复逻辑）。
      - 对关键路径编写回归脚本或最小集成测试：订阅→推理→推流、模型切换/动态热更新、
  REST 状态查询。
      - 梳理日志、错误处理、线程终止等细节。
      - 检查编译警告/平台兼容性，更新文档（README、设计目标与要点.md）。

  ———

  阶段 7（可选）：优化与扩展

  - 开启 GPU IOBinding、TensorRT 适配、WHIP/WHEP 标准协议改造等按需增强。
  - 引入单元测试框架（如 GoogleTest）覆盖核心模块。

  ———

  执行策略建议

  - 每个阶段独立提交，确保构建可通过、基本功能可运行，以便回退。
  - 在阶段边界增加简单的回归验证（REST 调用脚本、日志检查），避免功能倒退。
  - 若资源有限，可优先完成阶段 1~4（即内部重构），然后逐步替换 REST 层；必要时保留旧
  REST，对新 Pipeline 增量接入，减小切换风险。