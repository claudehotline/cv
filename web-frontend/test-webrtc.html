<!DOCTYPE html>
<html>
<head>
    <title>WebRTCæµ‹è¯• - æ— STUNçº¯æœ¬åœ°è¿æ¥</title>
    <style>
        body { font-family: Arial; padding: 20px; }
        video { width: 640px; height: 480px; background: #000; border: 2px solid #333; }
        button { margin: 10px; padding: 10px 20px; font-size: 16px; }
        #status { margin: 20px 0; padding: 10px; background: #f0f0f0; }
        .log { margin: 5px 0; font-family: monospace; font-size: 12px; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>
    <h1>WebRTC æµ‹è¯•é¡µé¢ - çº¯æœ¬åœ°è¿æ¥</h1>

    <div>
        <button onclick="connect()">1. è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨</button>
        <button onclick="requestOffer()">2. è¯·æ±‚è§†é¢‘æµ</button>
        <button onclick="disconnect()">æ–­å¼€è¿æ¥</button>
    </div>

    <video id="remoteVideo" autoplay muted playsinline></video>

    <div id="status">
        <h3>è¿æ¥çŠ¶æ€</h3>
        <div id="logs"></div>
    </div>

    <script>
        let ws = null;
        let pc = null;
        let clientId = null;

        function log(message, isError = false) {
            const logs = document.getElementById('logs');
            const div = document.createElement('div');
            div.className = 'log' + (isError ? ' error' : '');
            div.textContent = new Date().toLocaleTimeString() + ' - ' + message;
            logs.appendChild(div);

            // ä¸é™åˆ¶æ—¥å¿—æ•°é‡ï¼Œæ˜¾ç¤ºå…¨éƒ¨
            // while (logs.children.length > 10) {
            //     logs.removeChild(logs.firstChild);
            // }
            logs.scrollTop = logs.scrollHeight;
            console.log(message);
        }

        function connect() {
            const scheme = location.protocol === 'https:' ? 'wss://' : 'ws://';
            const signalingUrl = scheme + location.host + '/signaling';
            log('æ­£åœ¨è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨ ' + signalingUrl + ' ...');

            ws = new WebSocket(signalingUrl);

            ws.onopen = () => {
                log('âœ… WebSocketè¿æ¥æˆåŠŸï¼Œå‘é€è®¤è¯æ¶ˆæ¯', false);
                ws.send(JSON.stringify({
                    type: 'auth',
                    data: {
                        client_type: 'web_client',
                        client_id: 'test_' + Date.now()
                    }
                }));
            };

            ws.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                // åªè®°å½•é‡è¦æ¶ˆæ¯ï¼Œå¿½ç•¥ICEå€™é€‰å’Œåˆ†æç»“æœ
                if (message.type !== 'ice_candidate' && message.type !== 'analysis_result') {
                    log('æ”¶åˆ°æ¶ˆæ¯: ' + message.type);
                }

                switch(message.type) {
                    case 'auth_success':
                        clientId = message.client_id;
                        log('âœ… è®¤è¯æˆåŠŸï¼Œå®¢æˆ·ç«¯ID: ' + clientId, false);
                        break;

                    case 'offer':
                        log('ğŸ“¥ æ”¶åˆ°Offerï¼Œåˆ›å»ºAnswer...');
                        await handleOffer(message.data);
                        break;

                    case 'ice_candidate':
                        // ä¸è®°å½•æ¯ä¸ªICEå€™é€‰
                        await handleIceCandidate(message.data);
                        break;
                }
            };

            ws.onerror = (error) => {
                log('âŒ WebSocketé”™è¯¯: ' + error, true);
            };

            ws.onclose = () => {
                log('WebSocketè¿æ¥å·²å…³é—­');
            };
        }

        function requestOffer() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('âŒ è¯·å…ˆè¿æ¥ä¿¡ä»¤æœåŠ¡å™¨', true);
                return;
            }

            // åˆ›å»ºPeerConnection - çº¯æœ¬åœ°è¿æ¥ï¼Œä¸ä½¿ç”¨STUN/TURN
            const config = {
                iceServers: [],  // ç©ºæ•°ç»„ï¼Œåªä½¿ç”¨æœ¬åœ°å€™é€‰
                iceCandidatePoolSize: 0  // ä¸é¢„å…ˆæ”¶é›†å€™é€‰
            };

            pc = new RTCPeerConnection(config);
            log('âœ… åˆ›å»ºPeerConnection (çº¯æœ¬åœ°è¿æ¥ï¼Œæ— STUN)');

            pc.ontrack = (event) => {
                log('ğŸ“º æ”¶åˆ°è¿œç¨‹è§†é¢‘è½¨é“');
                const video = document.getElementById('remoteVideo');
                video.srcObject = event.streams[0];
                log('âœ… è§†é¢‘æµå·²è®¾ç½®åˆ°videoå…ƒç´ ', false);
            };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    // ä¸è®°å½•æ¯ä¸ªICEå€™é€‰ï¼Œå¤ªå¤šäº†
                    // log('å‘é€æœ¬åœ°ICEå€™é€‰: ' + event.candidate.candidate);
                    ws.send(JSON.stringify({
                        type: 'ice_candidate',
                        data: {
                            candidate: event.candidate.candidate,
                            sdpMid: event.candidate.sdpMid,
                            sdpMLineIndex: event.candidate.sdpMLineIndex
                        }
                    }));
                }
            };

            pc.onconnectionstatechange = () => {
                log('è¿æ¥çŠ¶æ€: ' + pc.connectionState);
                if (pc.connectionState === 'connected') {
                    log('âœ…âœ…âœ… WebRTCè¿æ¥æˆåŠŸå»ºç«‹ï¼', false);
                }
            };

            pc.oniceconnectionstatechange = () => {
                log('ICEè¿æ¥çŠ¶æ€: ' + pc.iceConnectionState);
            };

            // å‘é€è¯·æ±‚
            log('ğŸ“¤ å‘é€request_offeræ¶ˆæ¯');
            ws.send(JSON.stringify({
                type: 'request_offer',
                timestamp: Date.now()
            }));
        }

        async function handleOffer(offerData) {
            if (!pc) {
                log('âŒ PeerConnectionæœªåˆ›å»º', true);
                return;
            }

            try {
                log('è®¾ç½®è¿œç¨‹æè¿°(Offer)...');
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: offerData.sdp
                }));

                log('åˆ›å»ºAnswer...');
                const answer = await pc.createAnswer();

                // ä¿®æ”¹SDPä»¥ç¡®ä¿èƒ½æ¥æ”¶è§†é¢‘
                answer.sdp = answer.sdp.replace(/a=inactive/g, 'a=recvonly');

                log('è®¾ç½®æœ¬åœ°æè¿°(Answer)...');
                await pc.setLocalDescription(answer);

                log('ğŸ“¤ å‘é€Answeråˆ°æœåŠ¡å™¨');
                ws.send(JSON.stringify({
                    type: 'answer',
                    data: {
                        type: 'answer',
                        sdp: answer.sdp
                    }
                }));

                log('âœ… Answerå·²å‘é€', false);
            } catch (error) {
                log('âŒ å¤„ç†Offerå¤±è´¥: ' + error, true);
            }
        }

        async function handleIceCandidate(candidateData) {
            if (!pc) return;

            try {
                await pc.addIceCandidate(new RTCIceCandidate({
                    candidate: candidateData.candidate,
                    sdpMid: candidateData.sdpMid,
                    sdpMLineIndex: candidateData.sdpMLineIndex
                }));
                // ä¸è®°å½•æ¯ä¸ªICEå€™é€‰æ·»åŠ 
            } catch (error) {
                log('âš ï¸ æ·»åŠ ICEå€™é€‰å¤±è´¥: ' + error, true);
            }
        }

        function disconnect() {
            if (pc) {
                pc.close();
                pc = null;
            }
            if (ws) {
                ws.close();
                ws = null;
            }
            log('å·²æ–­å¼€æ‰€æœ‰è¿æ¥');
        }
    </script>
</body>
</html>
